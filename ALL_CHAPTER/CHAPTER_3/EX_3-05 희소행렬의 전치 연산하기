
#include <stdio.h>
typedef struct { //행렬 원소를 저장하기 위한 구조체 term 정의
	int row; //행
	int col; //열
	int value; //행과 열에 있는 값

} term; //객체 이름

void smTranspose(term a[], term b[]); //멤버함수 선언

void smTranspose(term a[], term b[]) {
	int m, n, v; //행, 열, 값
	int i, j, p; // for문 제어변수
	m = a[0].row; //11개의 행
	n = a[0].col; //7개의 열
	v = a[0].value; //10개의 개수

	//b를 전치를 한다
	b[0].row = n;  //a의 열 개수 7을 b[0].row에 넣음
	b[0].col = m; //a의 행 개수 11을 b[0].col에 넣음
	b[0].value = v; //a의 0아닌 원소 개수 10을 b[0].value에 넣음

	//원소가 0이 아닌 값일때 if문 실행
	if (v > 0) {
		p = 1; //0이 아닌 이유가 a나b의  0번째 인덱스 개수표시값이 들어가기 때문
		for (i = 0; i < n; i++) { //7만큼 반복 //이것은 열의 0부터 7까지 나열해서 검사 //나열해서값을 넣고싶어서 씀 //열 부분을 계산하는 이유는 a의 열 값이 b의 행에 들어가기 때문
			//그리고 c언어는 행우선이기 때문 //행은 바로앞에 나오니 뭔가 0~7부터 하면 그럴싸해 보여서
			for (j = 1; j <= v; j++) { // v번만큼 반복, 즉 0아닌 원소 개수 10번 반복 // 10번 반복하는 이유는 10개의 원소들을 검사할려고
				if (a[j].col == i) { // 현재 열에 속하는 원소가 있으면 b[]에 삽입 //만약 열이 2고 i가 0이면 안되고 6이면 안되고 4면 안되고 0이면 성립한다는 거임
					//즉, 이것은 전치행렬을 했을때 행이 0부터 나열되게 하는 방식이다. 나열도 해주는 클라스
					b[p].row = a[j].col; //b의 1번째 인덱스 행에 a의 9번째에 있는 열 0 을 넣겠다는 거임 이게 전치행렬
					b[p].col = a[j].row; //b의 1번째 인덱스 행에 a의 9번째에 있는 행 6을 넣겠다
					b[p].value = a[j].value; //값은 그대로 넣음
					p++; //다음 행에서 값 넣게 증가시킴
				}
			}
		}
	}
}
int main() {
	term a[] = { {8,7,10},{0,2,2},{0,6,12},{1,4,7},{2,0,23},{3,3,31},{4,1,14},{4,5,25},{5,6,6},{6,0,52},{7,4,11} }; //a[11][3], a[0]의 행개수,열개수,0이 아닌원소 수
	term b[sizeof(a) / sizeof(a[0])]; //배열 원소 개수 계산 //11개
	int i;

	printf("<<희소행렬 a>>");
	for (i = 0; i <= a[0].value; i++)
		printf("\n[%3d, %3d, %3d ]", a[i].row, a[i].col, a[i].value);
	
	smTranspose(a, b); //a와 b를 전치행렬을 함

	printf("\n\n<<희소행렬 b>>");
	for (i = 0; i <= b[0].value; i++)
		printf("\n [%3d, %3d, %3d ]", b[i].row, b[i].col, b[i].value);

	getchar(); return 0;





}
